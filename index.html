
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My iOS Journey</title>
  <meta name="author" content="zhao yan">

  
  <meta name="description" content="~ 特点 1 大部分程序的大部分指令之执行一次，或者最多几次。如果一个程序的所有指令都具有这样的性质，我们说这个程序的执行时间是常数。 logN 如果一个程序的运行时间是对数级的，则随着N的增大程序会渐渐慢下来，如果一个程序将一个大的问题分解成一系列更小的问题，每一步都将问题的规模缩减成几分之一 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhaoyan106.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My iOS Journey" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My iOS Journey</a></h1>
  
    <h2>Fighting And More</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zhaoyan106.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/22/suan-fa-de-shi-jian-xiao-lu/">算法的时间效率</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-22T11:08:59+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>11:08 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><table>
<thead>
<tr>
<th>~ </th>
<th> 特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 </td>
<td> 大部分程序的大部分指令之执行一次，或者最多几次。如果一个程序的所有指令都具有这样的性质，我们说这个程序的执行时间是常数。</td>
</tr>
<tr>
<td>logN  </td>
<td> 如果一个程序的运行时间是对数级的，则随着N的增大程序会渐渐慢下来，如果一个程序将一个大的问题分解成一系列更小的问题，每一步都将问题的规模缩减成几分之一，一般就会出现这样的运行时间函数。在我们所关心的范围内，可以认为运行时间小于一个大的常数。对数的基数会影响这个常数，但改变不会太大：当N=1000时，如果基数是10，logN等于3；如果基数是2，logN约等于10.当N=1 00 000，logN只是前值的两倍。当N时原来的两倍，logN只增长了一个常数因子：仅当从N增长到N平方时，logN才会增长到原来的两倍。</td>
</tr>
<tr>
<td>N </td>
<td> 如果程序的运行时间的线性的，很可能是这样的情况：对每个输入的元素都做了少量的处理。当N=1 000 000时，运行时间大概也就是这个数值；当N增长到原来的两倍时，运行时间大概也增长到原来的两倍。如果一个算法必须处理N个输入（或者产生N个输出），那么这种情况是最优的。</td>
</tr>
<tr>
<td>NlogN </td>
<td>  如果某个算法将问题分解成更小的子问题，独立地解决各个子问题，最后将结果综合起来，运行时间一般就是NlogN。我们找不到一个更好的形容，就暂且将这样的算法运行时间叫做NlogN。当N=1 000 000时，NlogN大约是20 000 000。当N增长到原来的两倍，运行时间超过原来的两倍，但超过不是太多。</td>
</tr>
<tr>
<td>N² </td>
<td> 如果一个算法的运行时间是二次的（quadratic），那么它一般只能用于一些规模较小的问题。这样的运行时间通常存在于需要处理每一对输入数据项的算法（在程序中很可能表现为一个嵌套循环）中，当N=1000时，运行时间是1 000 000；如果N增长到原来的两倍，则运行时间将增长到原来的四倍。</td>
</tr>
<tr>
<td>N的三次方 </td>
<td> 类似的，如果一个算法需要处理输入数据想的三元组（很可能表现为三重嵌套循环），其运行时间一般就是三次的，只能用于一些规模较小的问题。当N=100时，运行时间就是1 000 000；如果N增长到原来的两倍，运行时间将会增长到原来的八倍。</td>
</tr>
<tr>
<td>2的N次方 </td>
<td> 如果一个算法的运行时间是指数级的（exponential），一般它很难在实践中使用，即使这样的算法通常是对问题的直接求解。当N=20时，运行时间是1 000 000；如果增长到原来的两倍时，运行时间将是原时间的平方！</td>
</tr>
</tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/22/ba-da-pai-xu-suan-fa/">八大排序算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-22T10:36:43+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>插入排序：直接插入排序、希尔排序</h4>

<h6>1、插入排序</h6>

<h6>效率：</h6>

<p>稳定</p>

<p>空间复杂度O(1)</p>

<p>时间复杂度O(n2)</p>

<p>最差情况：反序，需要移动n*(n-1)/2个元素</p>

<p>最好情况：正序，不需要移动元素</p>

<p>数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)；</p>

<p>插入排序最坏情况运行时间和平均情况运行时间都为O(n²)。</p>

<p>通常，插入排序呈现出二次排序算法中的最佳性能。</p>

<p>对于具有较少元素（如n&lt;=15）的列表来说，二次算法十分有效。</p>

<p>在列表已被排序时，插入排序是线性算法O(n)。</p>

<p>在列表“近似排序”时，插入排序仍然是线性算法。</p>

<p>在列表的许多元素已位于正确的位置上时，就会出现“近似排序”的条件。</p>

<p>通过使用O(nlog2n)效率的算法（如快速排序）对数组进行部分排序，</p>

<p>然后再进行选择排序，某些高级的排序算法就是这样实现的。
2、希尔排序</p>

<h4>选择排序：简单的选择排序、堆排序</h4>

<p>1、选择排序</p>

<p>2、堆排序</p>

<h4>交换排序：冒泡排序、快速排序</h4>

<p>1、冒泡排序</p>

<p>2、快速排序</p>

<h4>归并排序</h4>

<h4>基数排序</h4>

<p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序</code>、<code>堆排序</code>或<code>归并排序</code></p>

<p><code>快速排序</code>：是目前基于<code>比较</code>的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/nsinvocationshi-yong/">NSInvocation使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-02T12:25:04+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h5>NSInvocation可以对某个对象发送消息(多参数使用),可以处理参数和返回值</h5>

<p>1、创建NSInvocation对象需要一个方法签名</p>

<pre><code>NSMethodSignature * sig = [self methodSignatureForSelector:sel]
</code></pre>

<p>2、利用得到的这个方法签名创建NSInvocation对象</p>

<pre><code>NSInvocation *inv = [NSInvocation invocationWithMethodSignature:sig];
</code></pre>

<p>3、通过调用NSInvocation的相关方法设置消息接收对象及参数</p>

<pre><code>[inv setTarget:self];
[inv setSelector:sel];
</code></pre>

<p>4、参数解析设置传参</p>

<pre><code>va_list args;
va_start(args, sel);
// 通过方法签名能够获取参数个数及参数类型
// [sig numberOfArguments]
// char *type = (char *)[sig getArgumentTypeAtIndex:index];
// 根据匹配出的类型通过va_arg取出入参
// int arg = va_arg(args, int);
[inv setArgument:&amp;arg atIndex:index];
</code></pre>

<p>5、调用执行方法</p>

<pre><code>[inv invoke]
</code></pre>

<p>6、获取方法返回值</p>

<pre><code>NSUInteger length = [sig methodReturnLength];
// 如果length为0方法返回为void
char *type = (char *)[sig methodReturnType];
// 根据type匹配出对应的类型，得到具体返回值
id ret = nil;
[inv getReturnValue:&amp;ret];
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/03/xiang-mu-cha-jian-hua-cocoapodsde-shi-yong/">项目插件化-CocoaPods的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-03T10:52:05+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>一、CocoaPods的安装</h4>

<h6>1、安装ruby环境,添加淘宝ruby镜像</h6>

<pre><code>$ gem sources --remove https://rubygems.org/
//等有反应之后再敲入以下命令
$ gem sources -a http://ruby.taobao.org/
</code></pre>

<h6>2、查看是否设置成功:</h6>

<pre><code>$ gem sources -l
</code></pre>

<h6>3、然后安装cocoapods:</h6>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h6>4、查看cocoapods是否支持某个类库</h6>

<pre><code>$ pod search 类库名,支持模糊查询(如:AFNetworking)
</code></pre>

<h4>二、CocoaPods的使用</h4>

<h6>1、在项目根目录下新建一个“Podfile”的文件</h6>

<p><code>注:Podfile也可以放在任何位置,但是需要在Podfile顶部使用”xcodeproj”关键字指定工程的路径,如下:</code></p>

<pre><code>xcodeproj"/User/Desktop/CocoaPodsDemo/CocoaPodsDemo.xcworkspace"
platform:ios
pod 'JSONKit',        '~&gt;1.4'
pod 'Reachability',  '~&gt;3.0.0'
pod 'AFNetworking',   '~&gt;2.2.4'
</code></pre>

<h6>2、在项目podfile所在目录下运行(会在你当前项目中导入podfile所配置的库,所以要在项目目录下运行)</h6>

<p><code>执行pod install命令后,生成的文件将在Podfile所在的目录</code></p>

<pre><code>$ pod install
</code></pre>

<p>注意上述命令运行完毕后终端输出的最后一段话,意思就是以后打开项目就用CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件</p>

<h4>三、使用过程中遇到的一些问题</h4>

<h6>1、引入第三方库后找不到头文件</h6>

<p>在项目的Targe- Build Settings - Search Paths - User Header Searcj Paths中添加 ${SRCROOT} 值为 recursive</p>

<h6>2、如何删除cocopods</h6>

<p>1、删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹</p>

<p>2、删除xcworkspace文件</p>

<p>3、使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用</p>

<p>4、在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources</p>

<h4>四、Podfile.lock文件的作用</h4>

<p>在使用CocoaPods，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。该文件用于保存已经安装的Pods依赖库的版本</p>

<p>Podfile.lock文件最大得用处在于多人开发。当团队中的某个人执行完pod install命令后，生成Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。</p>

<p><code>如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！</code></p>

<p>在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：</p>

<p>1、更改Podfile，使其指向最新版本的SBJson依赖库；</p>

<p>2、执行pod update命令；</p>

<p>鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。</p>

<h4>五、制作自己的Cocopods库</h4>

<h6>1、在github上新建一个工程</h6>

<p>license类型</p>

<p>正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>

<h5>2、podspec创建</h5>

<p>把项目clone到本地然后在根目录下新建MyPodDemo.podspec或者</p>

<pre><code>$ pod spec create MyPodDemo
</code></pre>

<p>podsepc的编写</p>

<pre><code>Pod::Spec.new do |s| 
s.name = "MyPodDemo" 
s.version = "0.0.1" 
s.summary = "A short description of MyPodDemo." 
s.description = &lt;&lt;-DESC A longer description of MyPodDemo in Markdown format. * Think: Why did you write this? What is the focus? What does it do? * CocoaPods will be using this to generate tags, and improve search results. * Try to keep it short, snappy and to the point. * Finally, don't worry about the indent, CocoaPods strips it! 
DESC 
s.homepage = "https://github.com/goingta/MyPodDemo" 
s.license = "MIT" s.author = { "goingta" =&gt; "tangle1128@gmail.com" } 
s.source = { :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" } s.source_files = "MyPodDemo/Src", "MyPodDemo/Src/**/*.{h,m}" 
s.requires_arc = true # s.framework = "SomeFramework" # 
s.frameworks = "SomeFramework", "AnotherFramework" 
# s.library = "iconv" 
# s.libraries = "iconv", "xml2" 
# s.dependency "JSONKit", "~&gt; 1.4" 
# s.dependency "AFNetworking", "~&gt; 2.2.4" end
</code></pre>

<p>属性解析</p>

<pre><code>name: 导入pod后的目录名 
version: 当前版本号 
deployment_target: 配置的target 
prefix_header_file: 预编译头文件路径，将该文件的内容插入到Pod的pch文件内 
source: 来源的具体路径，是http链接还是本地路径 
requires_arc: 是否需要arc 
source_files: 指定该目录下包含哪些文件 
其他可选参数还包括：
dependency: 指定依赖，如果依赖的库不存在或者依赖库的版本不符合要求将会报错 
libraries: 指定导入的库，比如sqlite3 
frameworks: 指定导入的framework 
weak_frameworks: 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。
</code></pre>

<p>整个podspec语法是一个嵌套结构从Pod::Spec.new do |s|到最后一个end是最大的循环，表示整个podspec导入的文件。中间每一个subspec到end结束是一个子目录，Pods会为每个subspec创建一个逻辑目录，相当于Xcode的group概念。|**|中间是subspec的名字，可以随便命名，但后面使用的名称必须一致。</p>

<p>通配符说明</p>

<pre><code>a{bb,bc}def.{h,m}表示四个文件abbdef.h abbdef.m abcdef.h abcdef.m

*.{h,m,mm}表示所有的.h .m .mm文件
Class/**/*.{h,m}表示Class目录下的所有.h .m文件
</code></pre>

<p>写完podspec文件后使用pod spec lint验证spec是否合格,有error则需要修改</p>

<p>配置非ARC文件
一个私有的pods库中某几个文件是在非ARC时代写的,如果要进行修改工程量浩大,于是乎要对这几个文件单独处理,这几个文件不使用arc其他文件使用arc,网上查了一些资料,只需要对source_file进行修改并排除那几个不使用ARC的文件就可以了,大致修改如下：</p>

<pre><code>Pod::Spec.new do |s| 
s.name = "MyPodDemo" s.version = "0.0.1" 
s.summary = "A short description of MyPodDemo. 
s.homepage = "https://github.com/goingta/MyPodDemo" 
s.license = "MIT" 
s.author = { "goingta" =&gt; "tangle1128@gmail.com" } 
s.source = { :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" } s.source_files = "MyPodDemo" 
non_arc_files = 'MyPodDemo/NoArcFile1.{h,m}','MyPodDemo/NoArcFile2.{h,m}' 
s.requires_arc = true 

s.exclude_files = non_arc_files 
s.subspec 'no-arc' do |sna| 
sna.requires_arc = false 
sna.source_files = non_arc_files 
end
</code></pre>

<h5>3、上传代码至github</h5>

<h5>4、私有库实现,编写podfile</h5>

<p>如果由于某些原因我们编写的库不能公开,但是又想使用pods来进行管理,要怎么办呢?</p>

<p>首先我们要将我们刚刚在github上建的仓库改为Private(不然还用Public搞毛啊)</p>

<p>然后修改我们项目的podfile,与已加入Cocopods仓库的公有库相比我们只需要指明私有库低git地址,如下:</p>

<pre><code>platform :ios, '6.0' 
pod 'MyPodDemo', :git =&gt; 'https://github.com/goingta/MyPodDemo.git' //私有库 
pod 'CocoaLumberjack'//公有库
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/13/effective-objective-c-2-dot-0zong-jie/">Effective Objective-C 2.0总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-13T15:32:57+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h6>第三条：多用字面量语法，少用预制等价的方法。</h6>

<p><code>需要注意 NSMutableArray *arrayM = [@[@"1",@"2",@"3"] mutableCopy];</code></p>

<h6>第四条：多用类型常量，少用#define预处理指令</h6>

<pre><code>#define ANIMATION_DURATION 0.3
Static const NSTimeInterval KAnimationDuration = 0.3;
</code></pre>

<h6>第七条：在对象内部尽量直接访问实例变量</h6>

<p><code>在对象内部读取时直接访问实例变量,设置时使用self.（懒加载除外）</code></p>

<p>  1、如果不使用self.可能会造成copy属性不能实现。</p>

<p>  2、KVO不触发</p>

<p>  3、直接读取效率较高</p>

<p>  4、子类可能重写get方法，使用_更安全</p>

<h6>第12条：理解消息转发机制 (✨✨✨✨✨✨)</h6>

<p><code>unrecongiezed selector send to instance 0x87,当找不到对应方法时会实现消息转发机制</code></p>

<p>对象在收到无法解读的消息后，首先会调用</p>

<pre><code>+ （BOOL)resolveInstanceMehtod:(SEL)selector
</code></pre>

<h6>第13条：用“方法调配技术” 调试 “黑盒方法”(✨✨✨✨✨✨)</h6>

<pre><code>// 交换方法实现
void method_exchangeImplementations(&lt;#Method m1#&gt;, &lt;#Method m2#&gt;)
// 获取对象方法
Method class_getInstanceMethod(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#SEL name#&gt;)
</code></pre>

<h6>第14条：理解“类对象”的用意</h6>

<pre><code>typedef struct objc_object{
    Class isa;
} *id;
</code></pre>

<h6>第15条：多用派发队列，少用同步锁</h6>

<p>同步锁效率较低</p>

<h6>第16条：多用GCD,少用performSelector系列方法</h6>

<p>在使用performSelector方法时容易引起ARC不自动使用，造成内存泄露。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/30/best-practices/">Best Practices</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-30T16:11:22+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:11 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Preferred:</p>

<pre><code>if (!error) {
    return success;
}
</code></pre>

<p>Not preferred:</p>

<pre><code>if (!error)
    return success;

or

if (!error) return success;
</code></pre>

<p>Preferred:</p>

<pre><code>if ([myValue isEqual:@42]) { ...
</code></pre>

<p>Not preferred:</p>

<pre><code>if ([@42 isEqual:myValue]) { ...
</code></pre>

<p>Preferred:</p>

<pre><code>if (nil == myValue) { ...
</code></pre>

<p>Not preferred:</p>

<pre><code>if (myValue == nil) { ...
</code></pre>

<p>Preferred:</p>

<pre><code>if (someObject) { ...
if (![someObject boolValue]) { ...
if (!someObject) { ...
</code></pre>

<p>Not preferred:</p>

<pre><code>if (someObject == YES) { ... // Wrong
if (myRawValue == YES) { ... // Never do this.
if ([someObject boolValue] == NO) { ...
</code></pre>

<p>Preferred:</p>

<pre><code>- (void)someMethod {
  if (![someOther boolValue]) {
      return;
  }

  //Do something important
}
</code></pre>

<p>Not preferred:</p>

<pre><code>- (void)someMethod {
  if ([someOther boolValue]) {
    //Do something important
  }
}
</code></pre>

<p>Preferred:</p>

<pre><code>BOOL nameContainsSwift  = [sessionName containsString:@"Swift"];
BOOL isCurrentYear      = [sessionDateCompontents year] == 2014;
BOOL isSwiftSession     = nameContainsSwift &amp;&amp; isCurrentYear;

if (isSwiftSession) {
    // Do something very cool
}
</code></pre>

<p>Not preferred:</p>

<pre><code>// 不建议写在一起，可读性差，容易出错
</code></pre>

<p>Preferred:</p>

<pre><code>result = object ? : [self createObject];
</code></pre>

<p>Not preferred:</p>

<pre><code>result = object ? object : [self createObject];
</code></pre>

<p>Preferred:</p>

<pre><code>NSError *error = nil;
if (![self trySomethingWithError:&amp;error]) {
    // Handle Error
}
</code></pre>

<p>Preferred:</p>

<pre><code>switch (menuType) {
    case ZOCEnumNone:
        // ...
        break;
    case ZOCEnumValue1:
        // ...
        break;
    case ZOCEnumValue2:
        // ...
        break;
}
// 如果有枚举没处理，会提示
</code></pre>

<p>Not preferred:</p>

<pre><code>switch (condition) {
    case 1:
        // ...
        break;
    case 2: {
        // ...
        // Multi-line example using braces
        break;
       }
    case 3:
        // ...
        break;
    default: 
        // ...
        break;
}
</code></pre>

<p>Preferred:</p>

<pre><code>typedef NS_ENUM(NSUInteger, ZOCMachineState) {
    ZOCMachineStateNone,
    ZOCMachineStateIdle,
    ZOCMachineStateRunning,
    ZOCMachineStatePaused
}
</code></pre>

<p>Preferred:</p>

<pre><code>static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";
static const CGFloat ZOCImageThumbnailHeight = 50.0f;
</code></pre>

<p>Not preferred:</p>

<pre><code>#define CompanyName @"Apple Inc."
#define magicNumber 42
</code></pre>

<p>Preferred:</p>

<pre><code>NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingZIPCode = @10018;
</code></pre>

<p>Not preferred:</p>

<pre><code>NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];
</code></pre>

<p>Preferred:</p>

<pre><code>+ (instancetype)sharedInstance
{
   static id sharedInstance = nil;
   static dispatch_once_t onceToken = 0;
   dispatch_once(&amp;onceToken, ^{
      sharedInstance = [[self alloc] init];
   });
   return sharedInstance;
}
</code></pre>

<p>Not preferred:</p>

<pre><code>+ (instancetype)sharedInstance
{
    static id sharedInstance;
    @synchronized(self) {
        if (sharedInstance == nil) {
            sharedInstance = [[MyClass alloc] init];
        }
    }
    return sharedInstance;
}
</code></pre>

<p>Preferred:</p>

<pre><code>view.backgroundColor = [UIColor orangeColor];
[UIApplication sharedApplication].delegate;
</code></pre>

<p>Not preferred:</p>

<pre><code>[view setBackgroundColor:[UIColor orangeColor]];
UIApplication.sharedApplication.delegate;
</code></pre>

<p>Lazy Loading</p>

<pre><code>- (NSDateFormatter *)dateFormatter {
  if (!_dateFormatter) {
    _dateFormatter = [[NSDateFormatter alloc] init];
        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
        [dateFormatter setLocale:enUSPOSIXLocale];
        [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSSSS"];
  }
  return _dateFormatter;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/21/nei-cun-cun-chu-xiang-guan-zhi-shi/">内存存储相关知识及static和extern关键字的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-21T17:10:27+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:10 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>一、程序的内存分配</h4>

<h6>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</h6>

<h6>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</h6>

<h6>3、全局区（静态区）（static）— 所有的全局变量都是静态变量、被关键字static修饰的局部变量也是静态变量<code>不改变其作用域</code></h6>

<pre><code>#include &lt;stdio.h&gt;
int a;
void test() {
    static int b = 0;
    b++;

    int c = 0;
    c++;

    printf("b=%d, c=%d \n", b, c);
}
int main() {
    int i;
    // 连续调用3次test函数
    for (i = 0; i&lt;3; i++) {
        test();
    }

    return 0;
}
* 第3行的变量a、第6行的变量b都是静态变量，第9行的变量c、第16行的变量i是自动变量。
* 因为第6行的变量b是静态变量，所以它只会被创建一次，而且生命周期会延续到程序结束。因为它只会创建一次，所以第6行代码只会执行一次，下次再调用test函数时，变量b的值不会被重新初始化为0。
</code></pre>

<h6>4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放</h6>

<h6>5、程序代码区—存放函数体的二进制代码。</h6>

<h4>二、static和extern关键字的使用</h4>

<h4>static和extern对函数的作用</h4>

<h6>1、外部、内部函数</h6>

<p>（1）外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。</p>

<p>（2）内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。</p>

<h6>2、static和extern对函数的作用</h6>

<p>（1）extern用来修饰外部函数，<code>extern跟auto关键字一样废，完全可以省略，因为默认情况下，所有的函数就是外部函数。</code>
extern关键字对函数的作用：用来定义和声明一个外部函数。其实extern又跟auto一样废，完全可以省略。</p>

<pre><code>void one();  // 等同于extern void one();
int main(){
one();
return 0;
}
</code></pre>

<p>（2）在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。<code>static也可以用来声明一个内部函数</code></p>

<h4>static和extern对变量的作用</h4>

<p>1.extern可以用来声明一个全局变量，但是不能用来定义变量</p>

<p>2.默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量</p>

<p>3.如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/16/iosying-yong-jia-gou/">iOS应用架构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-16T10:19:48+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:19 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在cocoaChina上看到一篇将iOS应用架构的文章<a href="http://www.cocoachina.com/ios/20150414/11557.html">http://www.cocoachina.com/ios/20150414/11557.html</a>，觉得不错，总结下.</p>

<h4>一、在设计app时需要注意的几点</h4>

<h6>1、网络层设计方案？设计网络层时要考虑哪些问题？对网络层做优化的时候，可以从哪些地方入手？</h6>

<h6>2、页面的展示、调用和组织都有哪些设计方案？我们做这些方案的时候都要考虑哪些问题？</h6>

<h6>3、本地持久化层的设计方案都有哪些？优劣势都是什么？不同方案间要注意的问题分别都是什么？</h6>

<h6>4、要实现动态部署，都有哪些方案？不同方案之间的优劣点，他们的侧重点？</h6>

<h6>5、如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？</h6>

<h6>6、页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？</h6>

<h6>7、当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？</h6>

<h6>8、iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？</h6>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/11/ya-suo-slash-jie-qu-shang-chuan-tu-pian/">压缩、截取上传图片,设置圆形UIImageView,App版本更新，设置tableView随textFiled焦点滑动</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-11T14:47:42+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:47 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>一、压缩、截取图片</h4>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    if (indexPath.row == 0) {
            UIActionSheet * actionsheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@"取消" destructiveButtonTitle:nil otherButtonTitles:@"拍照",@"从相册选择",nil];
            actionsheet.actionSheetStyle = UIActionSheetStyleAutomatic;
            [actionsheet showInView:self.view];
        }
}


- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex{

    if (buttonIndex == 0) { // 拍照
        [self takePhoto];
    }else if(buttonIndex == 1){ // 相册
        [self LocalPhoto];
    }else if (buttonIndex == 2) { // 取消

    }
}

//开始拍照
-(void)takePhoto
{
    UIImagePickerControllerSourceType sourceType = UIImagePickerControllerSourceTypeCamera;
    if ([UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera]){
        UIImagePickerController *picker = [[UIImagePickerController alloc] init];
        picker.delegate = self;
        picker.sourceType = sourceType;
        picker.allowsEditing = YES;
        [self presentViewController:picker animated:YES completion:nil];
    }else{
        NSLog(@"模拟器中无法打开照相机,请在真机中使用");
    }
}

//打开本地相册
-(void)LocalPhoto
{
    UIImagePickerController *picker = [[UIImagePickerController alloc] init];
    picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    picker.delegate = self;
    //设置选择后的图片可被编辑
    picker.allowsEditing = YES;
    [self presentViewController:picker animated:YES completion:nil];

}

//当选择一张图片后进入这里
-(void)imagePickerController:(UIImagePickerController*)picker didFinishPickingMediaWithInfo:(NSDictionary *)info
{
    UIImage* image = [info objectForKey:@"UIImagePickerControllerOriginalImage"];

    if (image != nil) {
       image = [self OriginImage:image scaleToSize:CGSizeMake(120, 120)];
        NSData *data;
        if (UIImagePNGRepresentation(image)) {
            //返回为png图像。
            data = UIImagePNGRepresentation(image);
        }else {
            //返回为JPEG图像。压缩比率设置0.3-0.7之间最好
            data = UIImageJPEGRepresentation(image, 0.5);
        }
        //此处网络请求
        [picker dismissViewControllerAnimated:YES completion:nil];
}


- (UIImage*)OriginImage:(UIImage *)image scaleToSize:(CGSize)size
{
    UIGraphicsBeginImageContext(size);  //size 为CGSize类型，即你所需要的图片尺寸

    [image drawInRect:CGRectMake(0, 0, size.width, size.height)];

    UIImage* scaledImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();

    return scaledImage;   //返回的就是已经改变的图片
}
</code></pre>

<h4>二、设置UIImageView为圆形</h4>

<pre><code>self.icon.layer.masksToBounds=YES;

self.icon.layer.cornerRadius= 30.0;    //最重要的是这个地方要设成imgview高的一半

self.outimgViewCusActivity.layer.borderWidth=1.0;
self.icon.backgroundColor = [UIColor whiteColor];
</code></pre>

<h4>三、APP版本更新</h4>

<pre><code>-(void)onCheckVersion
{
    NSDictionary *infoDic = [[NSBundle mainBundle] infoDictionary];
    //CFShow((__bridge CFTypeRef)(infoDic));
    NSString *currentVersion = [infoDic objectForKey:@"CFBundleVersion"];
    // 或者@""https://itunes.apple.com/lookup?bundleId=cn.keyno.$(PRODUCT_NAME:rfc1034identifier)"
    NSString *URL = @"http://itunes.apple.com/lookup?id=你的应用程序的ID";
    http://itunes.apple.com/lookup?id=你的应用程序的ID
    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
    [request setURL:[NSURL URLWithString:URL]];
    [request setHTTPMethod:@"POST"];
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
        [MBProgressHUD hideAllHUDsForView:self.view animated:YES];
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        NSArray *infoArray = [dic objectForKey:@"results"];
        if ([infoArray count]) {
            NSDictionary *releaseInfo = [infoArray objectAtIndex:0];
            NSString *lastVersion = [releaseInfo objectForKey:@"version"];

            if (![lastVersion isEqualToString:currentVersion]) {
                //trackViewURL = [releaseInfo objectForKey:@"trackVireUrl"];
                UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"更新" message:@"有新的版本更新，是否前往更新？" delegate:self cancelButtonTitle:@"关闭" otherButtonTitles:@"更新", nil];
                alert.tag = 10000;
                [alert show];
            }
            else
            {
                UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"更新" message:@"此版本为最新版本" delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil, nil];
                alert.tag = 10001;
                [alert show];
            }
        }
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"更新" message:@"有新的版本更新，是否前往更新？" delegate:self cancelButtonTitle:@"关闭" otherButtonTitles:@"更新", nil];
        alert.tag = 10000;
        [alert show];

    }];
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (alertView.tag==10000) {
        if (buttonIndex==1) {
            NSURL *url = [NSURL URLWithString:@"itms-apps://itunes.apple.com/app/id你的应用程序的ID"];
            [[UIApplication sharedApplication]openURL:url];
        }
    }
}

-(void)goToAppStore{
    NSString *str = [NSString stringWithFormat:
    @"itms-apps://ax.itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=%d",appID];
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
} 
    iOS7下苹果对app stotr的评分页面链接做了修改，及 
    NSString *str = [NSString stringWithFormat:

    @"itms-apps://itunes.apple.com/app/id%@",APPID];

    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<h4>四、设置tableView随textFiled焦点滑动</h4>

<h6>第一种方法：</h6>

<p>CGPoint origin = textField.frame.origin;</p>

<pre><code>CGPoint point = [textField.superview convertPoint:origin toView:self.tableView];

float navBarHeight = self.navigationController.navigationBar.frame.size.height;

CGPoint offset = self.tableView.contentOffset;

offset.y = (point.y - navBarHeight);

[self.tableView setContentOffset:offset animated:YES];
</code></pre>

<h6>第二种方法</h6>

<pre><code>CGPoint point = [textField.superview convertPoint:textField.frame.origin toView:self.tableView];

NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:point];

NSLog(@"%zd",indexPath.row);

[self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionTop animated:YES];
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/09/postqing-qiu-shang-chuan-wen-jian/">POST请求上传文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-09T13:56:50+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:56 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>利用POST请求发送文件数据,需要对数据进行拼接</h4>

<pre><code>----------httppost（\r\n）
Content-Disposition: form-data; name="img"; filename="t.txt" （\r\n）
Content-Type: application/octet-stream （\r\n）
（\r\n）
----------httppost（\r\n）
Content-Disposition: form-data; name="text" （\r\n）
（\r\n）
text tttt （\r\n）
----------httppost（\r\n）
</code></pre>

<h4>使用NSURLConnection发送POST上传文件</h4>

<pre><code>#define Encode(str) [str dataUsingEncoding:NSUTF8StringEncoding]

- (void)upload:(NSString *)name filename:(NSString *)filename mimeType:(NSString *)mimeType data:(NSData *)data parmas:(NSDictionary *)params
{
    // 文件上传
    NSURL *url = [NSURL URLWithString:@"http://127.0.0.1/upload"];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    request.HTTPMethod = @"POST";

    // 设置请求体
    NSMutableData *body = [NSMutableData data];

    /***************文件参数***************/
    // 参数开始的标志
    [body appendData:Encode(@"--ZY\r\n")];
    // name : 指定参数名(必须跟服务器端保持一致)
    // filename : 文件名
    NSString *disposition = [NSString stringWithFormat:@"Content-Disposition: form-data; name=\"%@\"; filename=\"%@\"\r\n", name, filename];
    [body appendData:Encode(disposition)];
    NSString *type = [NSString stringWithFormat:@"Content-Type: %@\r\n", mimeType];
    [body appendData:Encode(type)];

    [body appendData:Encode(@"\r\n")];
    [body appendData:data];
    [body appendData:Encode(@"\r\n")];

    /***************普通参数***************/
    [params enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
        // 参数开始的标志
        [body appendData:Encode(@"--ZY\r\n")];
        NSString *disposition = [NSString stringWithFormat:@"Content-Disposition: form-data; name=\"%@\"\r\n", key];
        [body appendData:Encode(disposition)];

        [body appendData:Encode(@"\r\n")];
        [body appendData:Encode(obj)];
        [body appendData:Encode(@"\r\n")];
    }];

    /***************参数结束***************/
    // ZY--\r\n
    [body appendData:Encode(@"--ZY--\r\n")];
    request.HTTPBody = body;

    // 设置请求头
    // 请求体的长度
    [request setValue:[NSString stringWithFormat:@"%zd", body.length] forHTTPHeaderField:@"Content-Length"];
    // 声明这个POST请求是个文件上传
    [request setValue:@"multipart/form-data; boundary=ZY" forHTTPHeaderField:@"Content-Type"];

    // 发送请求
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
        if (data) {
            NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
            NSLog(@"%@", dict);
        } else {
            NSLog(@"上传失败");
        }
    }];
}
</code></pre>

<h4>利用AFN框架发送POST上传文件请求</h4>

<pre><code>- (void)modifyUserIcon:(NSData *)data completion:(ResultInfoBlock)completion{
    // 1.获得请求管理者
    AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];
    // 2.发送请求(做文件上传)
    mgr.responseSerializer = [AFHTTPResponseSerializer serializer];
    [mgr POST:@"http://123.56.113.104:8081/upload" parameters:nil
constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    // 一定要在这个block中添加文件参数
    // 拼接文件参数
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    // 设置时间格式
    formatter.dateFormat = @"yyyyMMddHHmmss";
    NSString *str = [formatter stringFromDate:[NSDate date]];
    NSString *fileName = [NSString stringWithFormat:@"%@.png", str];
    [formData appendPartWithFileData:data name:@"imgFile" fileName:fileName mimeType:@"image/png"];
}
      success:^(AFHTTPRequestOperation *operation, id responseObject) {
          NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
          NSLog(@"上传成功----%@", dict);
          completion(dict,nil);
      } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
          NSLog(@"上传失败----%@", error);
          completion(nil,error);
      }];

}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/02/22/suan-fa-de-shi-jian-xiao-lu/">算法的时间效率</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/22/ba-da-pai-xu-suan-fa/">八大排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/02/nsinvocationshi-yong/">NSInvocation使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/03/xiang-mu-cha-jian-hua-cocoapodsde-shi-yong/">项目插件化-CocoaPods的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/13/effective-objective-c-2-dot-0zong-jie/">Effective Objective-C 2.0总结</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - zhao yan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
