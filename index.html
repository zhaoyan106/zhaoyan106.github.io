
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My iOS Journey</title>
  <meta name="author" content="zhao yan">

  
  <meta name="description" content="深拷贝:开辟新的存储空间,修改copy后的对象,不会影响本身 浅拷贝:只是指针的copy,修改copy后的对象,会影响本身. 对象要具备复制功能，必须实现协议或者协议，常用的可复制对象有： NSNumber、NSString、NSMutableString、NSArray、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhaoyan106.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My iOS Journey" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My iOS Journey</a></h1>
  
    <h2>Fighting And More</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zhaoyan106.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/23/shen-kao-bei-yu-qian-kao-bei-fen-xi/">深拷贝与浅拷贝分析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-23T09:37:21+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>9:37 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>深拷贝:开辟新的存储空间,修改copy后的对象,不会影响本身</p>

<p>浅拷贝:只是指针的copy,修改copy后的对象,会影响本身.</p>

<p>对象要具备复制功能，必须实现<NSCopying>协议或者<NSMutableCopying>协议，常用的可复制对象有：</p>

<p>NSNumber、NSString、NSMutableString、NSArray、NSMutableArray、NSDictionary、NSMutableDictionary</p>

<p>对于以上的Foundation都遵循这个规律(arrayI为不可变数组,arrayM为可变数组)</p>

<pre><code>(lldb) po arrayI
&lt;__NSArrayI 0x7fb620704ba0&gt;(

)

(lldb) po [arrayI copy]
&lt;__NSArrayI 0x7fb620704ba0&gt;(

)

(lldb) po [arrayI mutableCopy]
&lt;__NSArrayM 0x7fb62042d050&gt;(

)

(lldb) po arrayM
&lt;__NSArrayM 0x7fb620605570&gt;(

)

(lldb) po [arrayM copy]
&lt;__NSArrayI 0x7fb620704ba0&gt;(

)

(lldb) po [arrayM mutableCopy]
&lt;__NSArrayM 0x7fb620451ce0&gt;(

)
</code></pre>

<p>容器类对象深浅复制,对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝.</p>

<pre><code>  NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@"first"],[NSStringstringWithString:@"b"],@"c",nil];
    NSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];
    NSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:
    [NSKeyedArchiver archivedDataWithRootObject: array]];
</code></pre>

<p>自己实现深拷贝的方法</p>

<p>NSDictionaryMutableDeepCopy.h</p>

<pre><code>#import &lt;foundation /Foundation.h&gt;

@interface NSDictionary(MutableDeepCopy)

- (NSMutableDictionary *)mutableDeepCopy;

@end
</code></pre>

<p>NSDictionaryMutableDeepCopy.m</p>

<pre><code>#import "NSDictionaryMutableDeepCopy.h"

@implementation NSDictionary(MutableDeepCopy)

- (NSMutableDictionary *)mutableDeepCopy {
    NSMutableDictionary *ret = [[NSMutableDictionary alloc]
                                initWithCapacity:[self count]];
    NSArray *keys = [self allKeys];
    for (id key in keys) {
        id oneValue = [self valueForKey:key];
        id oneCopy = nil;

        if ([oneValue respondsToSelector:@selector(mutableDeepCopy)]) {
            oneCopy = [oneValue mutableDeepCopy];
        }
        else if ([oneValue respondsToSelector:@selector(mutableCopy)]) {
            oneCopy = [oneValue mutableCopy];
        }
        if (oneCopy == nil) {
            oneCopy = [oneValue copy];
        }
        [ret setValue:oneCopy forKey:key];
    }

    return ret;
}

@end
</code></pre>

<p>一般对象的拷贝,需要实现两个方法&lt;NSCopying,NSMutableCopying></p>

<p>浅拷贝</p>

<pre><code>-（id）copyWithZone:(NSZone *)zone{  

           Person *person = [[[self Class]allocWithZone:zone]init];  
           p.name = _name;  
           p.age = _age;  
           return person;  
       }  
</code></pre>

<p>深拷贝</p>

<pre><code>-(void)copyWithZone:(NSZone *)zone{  
            Person *person = [[[self Class]allocWithZone:zone]init];  
            person.name = [_name copy];  
            person.age = [_age copy];  
            return person;                    
        }  
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/13/li-yong-crashdui-zhan-xin-xi-ding-wei-dian-xing-de-ye-zhi-zhen-cuo-wu/">利用crash堆栈信息定位典型的野指针错误</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-13T17:13:23+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>通过堆栈信息，确定了代码的具体位置</p>

<pre><code>[self.delegate respondsToSelector:@selector(httpConnectionDidFailed:withError:)]
</code></pre>

<p>通过这个信息，猜测是delegate这个对象在网络请求回来之前已经释放掉，导致野指针错误。
控制器的具体代码如下：</p>

<pre><code>@interface TrainSearchListVC ()
// 这个HttpUtil是封装的网络工具类
@property (nonatomic, strong) HttpUtil *checkOrderUtil;
@property (nonatomic, strong) HttpUtil *cancelOrderUtil;

@end


- (void)dealloc
{
    [self unregisterNotification];
    // 首先要取消请求
    // 然后设置为nil (MRC需要release)
    ***因为没有设置为nil 导致野指针为题***
    [self.checkOrderUtil cancel];
    [self.cancelOrderUtil cancel];
    self.checkOrderUtil = nil;
    self.cancelOrderUtil = nil;
    [_tableViewList setDataSource:nil];
    [_tableViewList setDelegate:nil];
}

[_checkOrderUtil requestWithURLString:url Content:paramJson StartLoading:YES EndLoading:YES Delegate:self]; 设置了网络请求代理，但是当网络数据返回的时候，代理已经销毁了，出现也只真为题。
</code></pre>

<p>提供一个计算进制的python方法：</p>

<pre><code>EBJ1297:~ zhaoyan$ python
Python 2.7.6 (default, Sep  9 2014, 15:04:36) 
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hex(0x000f45f5 - 136693)
'0xd3000'
&gt;&gt;&gt; hex(0x00604963 - 5712227)
'0x92000'
&gt;&gt;&gt; hex(0x0059e963 - 5712227)
'0x2c000'
&gt;&gt;&gt; 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/12/li-yong-crashdui-zhan-xin-xi-ding-wei-dai-ma-beng-kui-wei-zhi/">利用crash堆栈信息定位代码崩溃位置</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-12T18:32:15+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>根据程序崩溃的堆栈信息确定代码crash位置,以下是一段crash堆栈信息</p>

<pre><code>........(
........0...Client.........................0x005c3963.ElongClient. .5712227,
........0,
........Client,
........0x005c3963.Client. .5712227,
........0x005c3963
....)
此crash堆栈信息,需要加入第三方管理,通过后台进行数据统计
</code></pre>

<p>使用下面的命令符号化,可以准确地定位crash代码的位置</p>

<pre><code>atos -arch armv7 -o .Dsyms路径 -l 0x52000 0x005c3963
</code></pre>

<p>在终端下输入该指令,结果或显示具体方法,具体文件,具体行数</p>

<pre><code>-[ViewController viewDidLoad] (ViewController.m:156)
</code></pre>

<p>0x52000是由0x005c3963减去10进制的5712227计算而得,.Dsyms文件是在程序打包的时候一起获得的文件(线上crash版本必须和这个配套)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/05/uiwebviewxiu-gai-ye-mian-xiang-guan/">UIWebView修改页面相关</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-05T17:56:03+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:56 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>UIWebView打开html后，UIWebView有左右滚动条，要去掉左右滚动效果；</p>

<p>方法：通过js截获UIWebView中的html，然后修改html标签内容；</p>

<p>实例代码： 服务器端html</p>

<pre><code>&lt;html&gt;&lt;head&gt;  
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;  
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;   
&lt;title&gt;网曝四川省一考场时钟慢半小时 老师称这就是命&lt;/title&gt;&lt;/head&lt;body&gt;网曝四川省一考场时钟慢半小时 老师称这就是命&lt;/body&gt;&lt;/html&gt; 
</code></pre>

<p>这样显示的结果网页的最小宽度会是device-width；但有时候不需要这个宽度，就需要修改width=device-width为width=myWidth;
客户端代码</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView  
{     
    //修改服务器页面的meta的值  
    NSString *meta = [NSString stringWithFormat:@"document.getElementsByName(\"viewport\")[0].content = \"width=%f, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"", webView.frame.size.width];  
    [webView stringByEvaluatingJavaScriptFromString:meta];  
}  
</code></pre>

<p>给网页增加utf-8编码</p>

<pre><code>[webView stringByEvaluatingJavaScriptFromString:  
 @"var tagHead =document.documentElement.firstChild;"  
  "var tagMeta = document.createElement(\"meta\");"   
  "tagMeta.setAttribute(\"http-equiv\", \"Content-Type\");"   
  "tagMeta.setAttribute(\"content\", \"text/html; charset=utf-8\");"   
  "var tagHeadAdd = tagHead.appendChild(tagMeta);"]; 
</code></pre>

<p>给网页增加css样式</p>

<pre><code>[webView stringByEvaluatingJavaScriptFromString:  
     @"var tagHead =document.documentElement.firstChild;"  
     "var tagStyle = document.createElement(\"style\");"   
     "tagStyle.setAttribute(\"type\", \"text/css\");"   
     "tagStyle.appendChild(document.createTextNode(\"BODY{padding: 20pt 15pt}\"));"  
     "var tagHeadAdd = tagHead.appendChild(tagStyle);"];
</code></pre>

<p>拦截网页图片  并修改图片大小</p>

<pre><code>[webView stringByEvaluatingJavaScriptFromString:  
 @"var script = document.createElement('script');"   
 "script.type = 'text/javascript';"   
 "script.text = \"function ResizeImages() { "   
     "var myimg,oldwidth;"  
     "var maxwidth=380;" //缩放系数   
     "for(i=0;i &lt;document.images.length;i++){"   
         "myimg = document.images[i];"  
         "if(myimg.width &gt; maxwidth){"   
             "oldwidth = myimg.width;"   
             "myimg.width = maxwidth;"   
             "myimg.height = myimg.height * (maxwidth/oldwidth);"   
         "}"   
     "}"   
 "}\";"   
 "document.getElementsByTagName('head')[0].appendChild(script);"];   
[webView stringByEvaluatingJavaScriptFromString:@"ResizeImages();"]; 
</code></pre>

<p>参考网址：</p>

<p>stringByEvaluatingJavaScriptFromString的使用方法:</p>

<p><a href="http://www.uml.org.cn/mobiledev/201108181.asp">http://www.uml.org.cn/mobiledev/201108181.asp</a></p>

<p>iphone 获取UIWebView内Html方法</p>

<p><a href="http://blog.csdn.net/diyagoanyhacker/article/details/6564897">http://blog.csdn.net/diyagoanyhacker/article/details/6564897</a></p>

<p>IOS UIWebView引用外部CSS样式</p>

<p><a href="http://hi.baidu.com/jwq359699768/item/780879e5c98bfb3e4ddcaf22">http://hi.baidu.com/jwq359699768/item/780879e5c98bfb3e4ddcaf22</a>
<a href="http://blog.csdn.net/xdonx/article/details/6973521">http://blog.csdn.net/xdonx/article/details/6973521</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/05/ioskai-fa-zhong-%5B%3F%5D-xie-xiao-ji-qiao/">iOS开发中一些小技巧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-05T11:13:29+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:13 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文地址：<a href="http://www.cocoachina.com/ios/20141231/10783.html">http://www.cocoachina.com/ios/20141231/10783.html</a>最近cocoachina上很火的一篇文章</p>

<h4>1.TableView不显示没内容的Cell</h4>

<pre><code>self.tableView.tableFooterView = [[UIView alloc] init];
</code></pre>

<h4>2.自定义了leftBarbuttonItem左滑返回手势失效了</h4>

<pre><code>self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]
                                     initWithImage:img
                                     style:UIBarButtonItemStylePlain
                                     target:self
                                     action:@selector(onBack:)];
self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;
</code></pre>

<p>在iOS7以后系统自动支持了左侧滑动返回功能,但当设置了左侧返回按钮,就会失效,这个方法很好地解决了问题</p>

<h4>3.ScrollView莫名其妙不能在viewController划到顶怎么办?</h4>

<pre><code>self.automaticallyAdjustsScrollViewInsets = NO;
</code></pre>

<p>这个功能也是iOS7之后系统带的功能</p>

<h4>4.像safari一样滑动的时候隐藏navigationbar?</h4>

<pre><code>navigationController.hidesBarsOnSwipe = Yes
</code></pre>

<h4>5.导航条返回键带的title太讨厌了,怎么让它消失!</h4>

<pre><code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h4>6.怎么把tableview里cell的小对勾的颜色改成别的颜色？</h4>

<pre><code>_mTableView.tintColor = [UIColor redColor];
</code></pre>

<h4>7.本来我的statusbar是lightcontent的，结果用UIImagePickerController会导致我的statusbar的样式变成黑色，怎么办？</h4>

<pre><code>- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated
{
    [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
}
</code></pre>

<h4>8.怎么把我的navigationbar弄成透明的而不是带模糊的效果？</h4>

<pre><code>[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
self.navigationBar.shadowImage = [UIImage new];
self.navigationBar.translucent = YES;
</code></pre>

<h4>9.怎么改变uitextfield placeholder的颜色和位置？</h4>

<pre><code>- (void) drawPlaceholderInRect:(CGRect)rect {
    [[UIColor blueColor] setFill];
    [self.placeholder drawInRect:rect withFont:self.font    lineBreakMode:UILineBreakModeTailTruncation alignment:self.textAlignment];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/24/chang-yong-gong-ju-fang-fa-zong-jie/">常用工具方法总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-24T10:02:28+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:02 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一.文件操作常用方法总结:</h3>

<h4>1.写入文件</h4>

<pre><code>+ (BOOL)writeFileName:(NSString *)fileName data:(id)result{
   NSString *pathName =  [LSCacheFile filePath:fileName];
    if ([LSCacheFile isExistsFile:pathName]) {
        [[NSFileManager defaultManager] removeItemAtPath:pathName error:nil];
    }
    return [LSCacheFile writeFile:pathName object:result];
}
</code></pre>

<h4>2.读出文件</h4>

<pre><code>+ (id)readFileName:(NSString *)fileName{

    if (!fileName) {
        return nil;
    }
    if(![LSCacheFile isExistsFile:fileName]){
        return nil;
    }

    id object = [LSCacheFile readFile:[LSCacheFile filePath:fileName]];
    if (!object) {
        return nil;
    }
    return object;
}
</code></pre>

<h4>3.计算文件大小</h4>

<pre><code>+ (NSString *)folderSizeStringAtPath:(NSString *)folderPath
{
    long long folderSize = [LSCacheFile folderSizeAtPath:folderPath];
    return [self sizeStringFromSizeLong:folderSize];
}

// 计算文件夹下文件的总大小
+ (long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager* manager = [NSFileManager defaultManager];
    if (![manager fileExistsAtPath:folderPath]) return 0;
    NSEnumerator *childFilesEnumerator = [[manager subpathsAtPath:folderPath] objectEnumerator];
    NSString* fileName;
    long long folderSize = 0;
    while ((fileName = [childFilesEnumerator nextObject]) != nil){
        NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
        folderSize += [LSCacheFile fileSizeAtPath:fileAbsolutePath];
    }
    return folderSize;
}
// 根据文件大小返回对应单位
+(NSString*)sizeStringFromSizeLong:(long long) folderSize{
    if (folderSize &lt; 1024) {
        return @"0K";
    }else if(folderSize/1024.0 &lt; 1024){
        return [NSString stringWithFormat:@"%.2fK",folderSize/1024.0];
    }else if(folderSize/1024.0/1024.0 &lt; 1024){
        return [NSString stringWithFormat:@"%.2fM",folderSize/1024.0/1024.0];
    }else if(folderSize/1024.0/1024.0/1024.0 &lt; 1024){
        return [NSString stringWithFormat:@"%.2fG",folderSize/1024.0/1024.0/1024.0];
    }
    return @"";
}
</code></pre>

<h4>4.格式化size单位</h4>

<pre><code>+ (NSString *)formatFileSize:(int)fileSize {
    float size = fileSize;
    if (fileSize &lt; 1023) {
        return([NSString stringWithFormat:@"%i bytes",fileSize]);
    }

    size = size / 1024.0f;
    if (size &lt; 1023) {
        return([NSString stringWithFormat:@"%1.2f KB",size]);
    }

    size = size / 1024.0f;
    if (size &lt; 1023) {
        return([NSString stringWithFormat:@"%1.2f MB",size]);
    }

    size = size / 1024.0f;
    return [NSString stringWithFormat:@"%1.2f GB",size];
}
</code></pre>

<h4>5.获取目录下的文件大小(返回字节)</h4>

<pre><code>+ (long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager* manager = [NSFileManager defaultManager];
    if (![manager fileExistsAtPath:folderPath]) return 0;
    NSEnumerator *childFilesEnumerator = [[manager subpathsAtPath:folderPath] objectEnumerator];
    NSString* fileName;
    long long folderSize = 0;
    while ((fileName = [childFilesEnumerator nextObject]) != nil){
        NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
        folderSize += [LSCacheFile fileSizeAtPath:fileAbsolutePath];
    }
    return folderSize;
}
</code></pre>

<h4>6.判断文件是否存在</h4>

<pre><code>+ (BOOL)isExistsFile:(NSString *)filepath{
    NSFileManager *filemanage = [NSFileManager defaultManager];
    return [filemanage fileExistsAtPath:[LSCacheFile filePath:filepath]];
}
</code></pre>

<h4>7.删除缓存文件</h4>

<pre><code>+(void)deleteCacheFile:(NSString *)filepath
{
    if([[NSFileManager defaultManager] fileExistsAtPath:filepath isDirectory:NO])
    {
        [[NSFileManager defaultManager] removeItemAtPath:filepath error:nil];
    }
}
</code></pre>

<h4>8.创建文件夹</h4>

<pre><code>+ (BOOL)createFolder:(NSString*)folderPath isDirectory:(BOOL)isDirectory {
    NSString *path = nil;
    if(isDirectory) {
        path = folderPath;
    } else {
        path = [folderPath stringByDeletingLastPathComponent];
    }

    if(folderPath &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:path] == NO) {
        NSError *error = nil;
        BOOL ret;

        ret = [[NSFileManager defaultManager] createDirectoryAtPath:path
                                        withIntermediateDirectories:YES
                                                         attributes:nil
                                                              error:&amp;error];
        if(!ret &amp;&amp; error) {
            NSLog(@"create folder failed at path '%@',error:%@,%@",folderPath,[error localizedDescription],[error localizedFailureReason]);
            return NO;
        }
    }

    return YES;
}
</code></pre>

<h4>9.得到用户document中的一个路径</h4>

<pre><code>+ (NSString*)getPathInUserDocument:(NSString*) aPath{
    NSString *fullPath = nil;
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    if ([paths count] &gt; 0)
    {
        fullPath = (NSString *)[paths objectAtIndex:0];
        if(aPath != nil &amp;&amp; [aPath compare:@""] != NSOrderedSame)
        {
            fullPath = [fullPath stringByAppendingPathComponent:aPath];
        }
    }
    return fullPath;
}
</code></pre>

<h4>10.文件创建日期</h4>

<pre><code>+ (NSDate*)dateOfFileCreateWithFolderName:(NSString *)folderName cacheName:(NSString *)cacheName
{
    NSString *folder = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:folderName];
    NSString *filePath = [folder stringByAppendingPathComponent:cacheName];
    NSError *error;
    NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:&amp;error];

    if(!error) {
        return [attributes objectForKey:NSFileCreationDate];
    }

    return nil;
}
</code></pre>

<h4>11.获取NSBundele中的资源图片</h4>

<pre><code>+ (UIImage *)imageAtApplicationDirectoryWithName:(NSString *)fileName {
    if(fileName) {
        NSString *path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:[fileName stringByDeletingPathExtension]];
        path = [NSString stringWithFormat:@"%@@2x.%@",path,[fileName pathExtension]];
        if(![[NSFileManager defaultManager] fileExistsAtPath:path]) {
            path = nil;
        }

        if(!path) {
            path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:fileName];
        }
        return [UIImage imageWithContentsOfFile:path];
    }
    return nil;
}
</code></pre>

<h4>12.移除某个文件夹下的所有文件(非遍历)并重新创建被删除的文件夹</h4>

<pre><code>+ (void) deleteContentsOfFolder:(NSString *)folderPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:folderPath error:nil];
    BOOL isDir = NO;
    BOOL existed = [fileManager fileExistsAtPath:folderPath isDirectory:&amp;isDir];
    if ( !(isDir == YES &amp;&amp; existed == YES) ) {
        [fileManager createDirectoryAtPath:folderPath withIntermediateDirectories:YES attributes:nil error:nil];
    }
}
</code></pre>

<h3>二.文件操作常用方法总结:</h3>

<h4>1.获取请求sign</h4>

<pre><code>+(NSString *)getSign{
    NSString *username = @"zhaoyan106";
    NSString *pwd = @"zhaoyan106";
    NSString *pwd_md5 = [pwd md5];
    NSString *time_key_md5 = [[NSString stringWithFormat:@"%@%@",[self getTimeStamp],@"zhaoyan106"] md5];
    NSString *sign = [[NSString stringWithFormat:@"%@%@%@",username, pwd_md5,time_key_md5] md5];
    return sign;
}

- (NSString*)md5 {
    const char* string = [self UTF8String];
    unsigned char result[16];
    CC_MD5(string, strlen(string), result);
    NSString* hash = [NSString stringWithFormat:@"%@%@@%%@%@@@%@@%@@%@@@@@%@@@@%@@@%@@%@@@%@@%",
                      result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7],
                      result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]];
    return [hash lowercaseString];
}

// 获取时间戳
+(NSString *)getTimeStamp{
    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
    NSTimeInterval a=[dat timeIntervalSince1970];
    NSString *timeString = [NSString stringWithFormat:@"%.0f", a];
    return timeString;
}
</code></pre>

<h4>2.获取时间戳</h4>

<pre><code>+(NSString *)getTimeStamp{
    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
    NSTimeInterval a=[dat timeIntervalSince1970];
    NSString *timeString = [NSString stringWithFormat:@"%.0f", a];
    return timeString;
}
</code></pre>

<h4>3.将对象转化为json字符串</h4>

<pre><code>+ (NSString *)jsonStringFromObject:(id)object{
    if([NSJSONSerialization isValidJSONObject:object]){
        NSData *data = [NSJSONSerialization dataWithJSONObject:object options:NSJSONWritingPrettyPrinted error:nil];
        NSString *jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        return jsonString;
    }
    return @"";
}
</code></pre>

<h4>4.去除字典元素(去除NSNull)</h4>

<pre><code>+ (id)valueForKey:(NSString *)key object:(NSDictionary *)object{
    if([object isKindOfClass:[NSDictionary class]]){
        id value = [object objectForKey:key];
        if([value isKindOfClass:[NSNull class]]){
            return nil;
        }
        return value;
    }
    return nil;
}
</code></pre>

<h4>5.http request header 访问信息</h4>

<p>关于UDID等标识不清楚的可以参考下这篇文章<a href="http://www.cocoachina.com/industry/20130715/6597.html">http://www.cocoachina.com/industry/20130715/6597.html</a></p>

<pre><code>+ (NSString *)getTraceInfo {
    //版本号
    NSString *versionname  = [NSString stringWithFormat:@"%.1f", ((NSString *)[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"]).integerValue-1.0+7.0];
    //内部版本
    NSString *versioncode  = ([[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"]);
    //发布版本
    NSString *buildversion = ([[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"]);
    //系统版本
    NSString *osversion = [[UIDevice currentDevice] systemVersion];
    //设备型号
    NSString *model = [self deviceType];
    //软件名称
    NSString *appname = @"stem";
    //软件平台
    NSString *clientname = @"iphone";
    //广告唯一标识符
    NSString *idfa = [self getAdvertisingIdentifier];
    //UDID
    NSString *clientid = [LSHelper getCurrentDeviceUDID];
//    NSString *traceInfo = [NSString stringWithFormat:@"versionname=%@;appname=%@;clientname=%@;",versionname,appname,clientname];
    NSString *traceInfo = [NSString stringWithFormat:@"versionname=%@;versioncode=%@;buildversion=%@;osversion=%@;model=%@;appname=%@;clientname=%@;idfa=%@;clientid=%@;",versionname,versioncode,buildversion,osversion,model,appname,clientname,idfa,clientid];
    return traceInfo;
}

// 获取当前设备类型如ipod，iphone，ipad
+ (NSString *)deviceType {
    struct utsname systemInfo;
    uname(&amp;systemInfo);
    return [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
}

// 获取用户的ADFA
+ (NSString *) getAdvertisingIdentifier{
    return [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];
}

// 获取当前设备的UDID
+(NSString*) getCurrentDeviceUDID
{
    if ([self getCurrentDeviceVersion]&gt;=7.0) {
    // OpenUDID
        return [OpenUDID value];
    }else{
        return [self UUID];
    }

}


// 获取当前设备的UDID(ios7.0以下系统)
+ (NSString *)UUID {
    NSInteger mib[6];
    size_t              len;
    char                *buf;
    unsigned char       *ptr;
    struct if_msghdr    *ifm;
    struct sockaddr_dl  *sdl;

    mib[0] = CTL_NET;
    mib[1] = AF_ROUTE;
    mib[2] = 0;
    mib[3] = AF_LINK;
    mib[4] = NET_RT_IFLIST;

    if ((mib[5] = if_nametoindex("en0")) == 0) {
        printf("Error: if_nametoindex error\n");
        return NULL;
    }

    if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) {
        printf("Error: sysctl, take 1\n");
        return NULL;
    }

    if ((buf = malloc(len)) == NULL) {
        printf("Could not allocate memory. error!\n");
        return NULL;
    }

    if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) {
        free(buf);
        printf("Error: sysctl, take 2");
        return NULL;
    }

    ifm = (struct if_msghdr *)buf;
    sdl = (struct sockaddr_dl *)(ifm + 1);
    ptr = (unsigned char *)LLADDR(sdl);
    NSString *macaddress = [NSString stringWithFormat:@"%02X:%02X:%02X:%02X:%02X:%02X",
                            *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];
    free(buf);


    if (macaddress) {
        NSString *uniqueIdentifier = [macaddress stringByReplacingOccurrencesOfString:@":" withString:@""];
        return uniqueIdentifier;
    } else {
        NSUserDefaults *handler = [NSUserDefaults standardUserDefaults];
        NSString *result = (NSString *)[handler objectForKey:kUUID];

        if (NULL == result || 46 &gt; [result length]) {
            CFUUIDRef uuid = CFUUIDCreate(NULL);
            CFStringRef uuidStr = CFUUIDCreateString(NULL, uuid);

            result = [NSString stringWithFormat:@"%@", uuidStr];
            CFRelease(uuidStr);
            CFRelease(uuid);

            [handler setObject:result forKey:kUUID];
            [handler synchronize];
        }

        return result;
    }
}
</code></pre>

<h4>6.(参数 + url)md5加密</h4>

<pre><code>+(NSString *)keyMD5StringWithParamDic:(NSDictionary *)paramDic methodName:(NSString *)methodName
{
    NSMutableString *keyMutableString = nil;
    if (paramDic == nil) {
        return nil;
    }

    NSArray *keys = [paramDic allKeys];
    NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        return [obj1 compare:obj2 options:NSNumericSearch];
    }];

    keyMutableString = [NSMutableString string];
    for (NSInteger index = 0; index &lt; sortedArray.count; index++) {
        NSString *key = [sortedArray objectAtIndex:index];
        NSString *value = [paramDic objectForKey:key];
        if (index == 0) {
            [keyMutableString appendFormat:@"%@=%@",key,value];
        } else {
            [keyMutableString appendFormat:@"|%@=%@",key,value];
        }
    }
    NSString *url = [NSString stringWithFormat:@"%@%@",kServerAddress,methodName];
    [keyMutableString appendString:url];
    return [keyMutableString md5];
}
</code></pre>

<h4>7.cookie操作</h4>

<pre><code>// 设置cooike
+ (void)setHttpCookieValue:(NSString *)value{
    //过期时间一个小时
    NSDate *date = [NSDate dateWithTimeIntervalSinceNow:60*60];
    //设置了过期时间，如果过期，则NSURLRequest就不会使用此cookie
    NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:@{NSHTTPCookiePath:@"/", NSHTTPCookieName:@"JSESSIONID", NSHTTPCookieValue:value, NSHTTPCookieOriginURL:kServerAddress, NSHTTPCookieExpires:date}];
    [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
    [self writeFileName:kSpecialCookieFileName data:@[cookie]];
}
// 读取cookie
+ (NSString *)valueFromHttpCookie{
    NSArray *cookieArr = [self readFileName:kSpecialCookieFileName];
    NSMutableArray *mutableArr = [NSMutableArray arrayWithArray:cookieArr];
    NSString *value = nil;
    for(NSHTTPCookie *cookie in cookieArr){
        if([cookie.name isEqual:@"JSESSIONID"] &amp;&amp; cookie.value.length &gt; 0){
            //如果过期了，则删除本地
            if([cookie.expiresDate compare:[NSDate date]] == NSOrderedAscending){
                [mutableArr removeObject:cookie];
            }
            else{
                [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
                value = cookie.value;
            }
        }
    }
    [self writeFileName:kSpecialCookieFileName data:mutableArr];
    return value;
}
// 删除cookie
+ (void)removeHttpCookieCache{
    [self deleteCacheFile:kSpecialCookieFileName];
}
</code></pre>

<h3>三.时间常用方法总结:</h3>

<h4>1.获取当前时间</h4>

<pre><code>+ (NSString *)getCurrentTime
{
    NSDate *senddate = [NSDate date];

    NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];

    [dateformatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];

    NSString *locationString = [dateformatter stringFromDate:senddate];

    return locationString;

}
</code></pre>

<h4>2.字符时间转date</h4>

<pre><code>+ (NSDate *)dateFromString:(NSString *)dateString {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"eee, dd MMM yyyy HH:mm:ss ZZZZ"];
    NSDate *date = [formatter dateFromString:dateString];
    return date;
}
</code></pre>

<h4>3.date转字符串</h4>

<pre><code>+ (NSString *)stringFromDate:(NSDate *)date {
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //zzz表示时区，zzz可以删除，这样返回的日期字符将不包含时区信息。
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    NSString *destDateString = [dateFormatter stringFromDate:date];
    return destDateString;
}
</code></pre>

<h4>4.自1970年距离现在时间转换</h4>

<pre><code>+ (NSString *)timeFactorySeconds:(NSNumber *)seconds andFormat:(TimeFormat)type {
    float second = [seconds doubleValue];
    if (second == 0) {
        return nil;
    }
    NSString *result = nil;
    NSDate *date = [NSDate dateWithTimeIntervalSince1970:[seconds doubleValue]/1000];
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    switch (type) {
        case YearMonthDayHourMin: {
            [formatter setDateFormat:@"yyyy-MM-dd HH:mm"];
            result = [formatter stringFromDate:date];
        }
            break;
        case YearMonthDay: {
            [formatter setDateFormat:@"yyyy-MM-dd"];
            result = [formatter stringFromDate:date];
        }
            break;
        case MonthDayHourMin: {
            [formatter setDateFormat:@"MM-dd HH:mm"];
            result = [formatter stringFromDate:date];
        }
            break;
        case YearMonthDayHZ: {
            [formatter setDateFormat:@"yyyy年MM月dd日"];
            result = [formatter stringFromDate:date];
        }
            break;
        default:
            break;
    }
    return result;
}
</code></pre>

<h4>5. 数组按时间排序</h4>

<pre><code>//数组按时间排序
+ (NSArray *)resortHomePageData:(NSArray *)data {
// NSSortDescriptor可以直接对对象的某个属性进行排列
    NSArray *sortDescriptors = [NSArray arrayWithObject:[NSSortDescriptor sortDescriptorWithKey:@"mtime" ascending:YES]];
    return [data sortedArrayUsingDescriptors:sortDescriptors];
}
</code></pre>

<h3>四.图片操作</h3>

<h4>1.去最大的正方形</h4>

<pre><code>+ (UIImage *)cutToRect:(UIImage *)image {
    double width = ((UIImage *)image).size.width * image.scale;
    double height = ((UIImage *)image).size.height * image.scale;
    UIImage *img = nil;
    if (width &gt; height) {
        CGImageRef imageRef = CGImageCreateWithImageInRect([image CGImage], CGRectMake((width - height)/2.0f, 0, height, height));
        img = [UIImage imageWithCGImage:imageRef scale:image.scale orientation:image.imageOrientation];
        CGImageRelease(imageRef);
    }
    else {
        CGImageRef imageRef = CGImageCreateWithImageInRect([image CGImage], CGRectMake(0, (height - width)/2.0f, width, width));
        img = [UIImage imageWithCGImage:imageRef scale:image.scale orientation:image.imageOrientation];
        CGImageRelease(imageRef);
    }
    return img;
}
</code></pre>

<h4>2.按比例取最大图片</h4>

<pre><code>+ (UIImage *)cutToBigRect:(UIImage *)image size:(CGSize)size {
    UIImage *imageRemove = [self imageResize:image size:image.size];//去掉拍照 图片带的方向信息
    double width = imageRemove.size.width * imageRemove.scale;
    double height = imageRemove.size.height * imageRemove.scale;
    UIImage *img = nil;
    CGImageRef imageRef;
    if (height / width &lt;= size.height / size.width) {//height小
        imageRef = CGImageCreateWithImageInRect([imageRemove CGImage], CGRectMake((width - height * (size.width / size.height))/2.0f, 0, height * (size.width / size.height), height));
    }
    else {
        imageRef = CGImageCreateWithImageInRect([imageRemove CGImage], CGRectMake(0, (height - width * (size.height / size.width))/2.0f, width, width * (size.height / size.width)));

    }
    img = [UIImage imageWithCGImage:imageRef scale:imageRemove.scale orientation:imageRemove.imageOrientation];
    CGImageRelease(imageRef);
    return img;
}
</code></pre>

<h4>3.将图片放缩到指定大小</h4>

<pre><code>+ (UIImage*)imageResize:(UIImage*)image size:(CGSize)size {
    UIGraphicsBeginImageContext(size);
    [image drawInRect:CGRectMake(0,0,size.width, size.height)];
    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/21/pu-bu-liu-(mo-fang-tableview)/">瀑布流（模仿TableView）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-21T16:22:24+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>4:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在一些应用中也许会用到一瀑布流来展示信息。以下是用的模仿TableView的写法，之后会写一篇iOS6之后能使用的collcetionView。</p>

<p>首先模仿tableView的数据源方法（用来控制有多少数据，多少列，返回的具体cell）：</p>

<pre><code>/**
 *  数据源方法
*/
@protocol HMWaterflowViewDataSource &lt;NSObject&gt;
@required
/**
 *  一共有多少个数据
*/
- (NSUInteger)numberOfCellsInWaterflowView:(HMWaterflowView *)waterflowView;
/**
 *  返回index位置对应的cell
 */
- (HMWaterflowViewCell *)waterflowView:(HMWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index;

@optional
/**
*  一共有多少列
*/
- (NSUInteger)numberOfColumnsInWaterflowView:(HMWaterflowView *)waterflowView;
@end
代理方法(用来控制每个cell的高度，间距和监听cell的点击):

/**
 *  代理方法
*/
@protocol HMWaterflowViewDelegate &lt;UIScrollViewDelegate&gt;
@optional
/**
 *  第index位置cell对应的高度
*/
- (CGFloat)waterflowView:(HMWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index;
/**
 *  选中第index位置的cell
 */
- (void)waterflowView:(HMWaterflowView *)waterflowView didSelectAtIndex:(NSUInteger)index;
/**
 *  返回间距
 */
- (CGFloat)waterflowView:(HMWaterflowView *)waterflowView marginForType:(HMWaterflowViewMarginType)type;

@end
</code></pre>

<p>首选写瀑布流有一点是必须清楚的，那就是每个cell的宽度是相同的，每个cell的高度是服务器返回的数据（因此有些图片需要根据宽高比进行缩放），由于需要考虑到每个cell的复用，还需要提供具体对应的dequeueReusableCellWithIdentifier和reloadData方法。</p>

<p>说到复用就必须要有一个缓存池，还有一个展示池（正在显示的cell），因为展示池需要判断cell的位置，这个池使用字典：</p>

<pre><code>/**
*  正在展示的cell
*/
@property (nonatomic, strong) NSMutableDictionary *displayingCells;
缓存池只负责存放因为不需要顺序，使用集合

/**
 *  缓存池（用Set，存放离开屏幕的cell）
*/
@property (nonatomic, strong) NSMutableSet *reusableCells;
另外还需要一个存放所有cell的Frame的数组

/**
*  所有cell的frame数据
*/
@property (nonatomic, strong) NSMutableArray *cellFrames;
</code></pre>

<p>通过reloadData方法计算出每个cell的Frame，并且计算出需要展示的contentSize</p>

<pre><code>- (void)reloadData
{
    // 清空之前的所有数据
    // 移除正在正在显示cell
    [self.displayingCells.allValues makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.displayingCells removeAllObjects];
    [self.cellFrames removeAllObjects];
    [self.reusableCells removeAllObjects];

    // cell的总数
    int numberOfCells = [self.dataSource numberOfCellsInWaterflowView:self];

    // 总列数
    int numberOfColumns = [self numberOfColumns];

    // 间距
    CGFloat topM = [self marginForType:HMWaterflowViewMarginTypeTop];
    CGFloat bottomM = [self marginForType:HMWaterflowViewMarginTypeBottom];
    CGFloat leftM = [self marginForType:HMWaterflowViewMarginTypeLeft];
    CGFloat columnM = [self marginForType:HMWaterflowViewMarginTypeColumn];
    CGFloat rowM = [self marginForType:HMWaterflowViewMarginTypeRow];

    // cell的宽度
    CGFloat cellW = [self cellWidth];

    // 用一个C语言数组存放所有列的最大Y值
    CGFloat maxYOfColumns[numberOfColumns];
    for (int i = 0; i&lt;numberOfColumns; i++) {
        maxYOfColumns[i] = 0.0;
    }

    // 计算所有cell的frame
    for (int i = 0; i&lt;numberOfCells; i++) {
        // cell处在第几列(最短的一列)
        NSUInteger cellColumn = 0;
        // cell所处那列的最大Y值(最短那一列的最大Y值)
        CGFloat maxYOfCellColumn = maxYOfColumns[cellColumn];
        // 求出最短的一列
        for (int j = 1; j&lt;numberOfColumns; j++) {
            if (maxYOfColumns[j] &lt; maxYOfCellColumn) {
                cellColumn = j;
                maxYOfCellColumn = maxYOfColumns[j];
            }
        }

        // 询问代理i位置的高度
        CGFloat cellH = [self heightAtIndex:i];

        // cell的位置
        CGFloat cellX = leftM + cellColumn * (cellW + columnM);
        CGFloat cellY = 0;
        if (maxYOfCellColumn == 0.0) { // 首行
            cellY = topM;
        } else {
            cellY = maxYOfCellColumn + rowM;
        }

        // 添加frame到数组中
        CGRect cellFrame = CGRectMake(cellX, cellY, cellW, cellH);
        [self.cellFrames addObject:[NSValue valueWithCGRect:cellFrame]];

        // 更新最短那一列的最大Y值
        maxYOfColumns[cellColumn] = CGRectGetMaxY(cellFrame);
    }

    // 设置contentSize
    CGFloat contentH = maxYOfColumns[0];
    for (int j = 1; j&lt;numberOfColumns; j++) {
        if (maxYOfColumns[j] &gt; contentH) {
            contentH = maxYOfColumns[j];
        }
    }
    contentH += bottomM;
    self.contentSize = CGSizeMake(0, contentH);
}
</code></pre>

<p>当屏幕滚动的时候会调用layoutSubviews方法，在这里我们根据cell是否显示对缓存池和展示池进行相关操作：</p>

<pre><code>- (void)layoutSubviews
{
    [super layoutSubviews];
    // 向数据源索要对应位置的cell
    NSUInteger numberOfCells = self.cellFrames.count;
    for (int i = 0; i&lt;numberOfCells; i++) {
        // 取出i位置的frame
        CGRect cellFrame = [self.cellFrames[i] CGRectValue];

        // 优先从字典中取出i位置的cell
        HMWaterflowViewCell *cell = self.displayingCells[@(i)];

        // 判断i位置对应的frame在不在屏幕上（能否看见）
        if ([self isInScreen:cellFrame]) { // 在屏幕上
            if (cell == nil) {
                cell = [self.dataSource waterflowView:self cellAtIndex:i];
                cell.frame = cellFrame;
                [self addSubview:cell];

                // 存放到字典中
                self.displayingCells[@(i)] = cell;
            }
        } else {  // 不在屏幕上
            if (cell) {
                // 从scrollView和字典中移除
                [cell removeFromSuperview];
                [self.displayingCells removeObjectForKey:@(i)];

                // 存放进缓存池
                [self.reusableCells addObject:cell];
            }
        }
    }
}
</code></pre>

<p>下面方法判断cell的frame是否在屏幕上：</p>

<pre><code>- (BOOL)isInScreen:(CGRect)frame
{
    return (CGRectGetMaxY(frame) &gt; self.contentOffset.y) &amp;&amp;
    (CGRectGetMinY(frame) &lt; self.contentOffset.y + self.bounds.size.height);
}
下面方法根据标记取出缓存池中的cell

- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier
{
    __block HMWaterflowViewCell *reusableCell = nil;

    [self.reusableCells enumerateObjectsUsingBlock:^(HMWaterflowViewCell *cell, BOOL *stop) {
        if ([cell.identifier isEqualToString:identifier]) {
            reusableCell = cell;
            *stop = YES;
        }
    }];

    if (reusableCell) { // 从缓存池中移除
        [self.reusableCells removeObject:reusableCell];
    }
    return reusableCell;
}
</code></pre>

<p>下面方法处理cell的点击</p>

<pre><code>- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    if (![self.delegate respondsToSelector:@selector(waterflowView:didSelectAtIndex:)]) return;

    // 获得触摸点
    UITouch *touch = [touches anyObject];
    //    CGPoint point = [touch locationInView:touch.view];
    CGPoint point = [touch locationInView:self];

    __block NSNumber *selectIndex = nil;
    [self.displayingCells enumerateKeysAndObjectsUsingBlock:^(id key, HMWaterflowViewCell *cell, BOOL *stop) {
        if (CGRectContainsPoint(cell.frame, point)) {
            selectIndex = key;
            *stop = YES;
        }
    }];

    if (selectIndex) {
        [self.delegate waterflowView:self didSelectAtIndex:selectIndex.unsignedIntegerValue];
    }
}
</code></pre>

<p>这样一个模仿tableView的瀑布流就写好了，下篇博客会介绍利用collectionView写瀑布流的方法。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/19/pu-bu-liu-(collectionviewzi-ding-yi-bu-ju-)/">瀑布流（collectionView自定义布局）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-19T14:47:19+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>2:47 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/30/ding-wei-ji-di-li-bian-ma/">定位及地理编码</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-30T17:04:55+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>定位</h4>

<p>在iOS8中,取消了之前的定位调用方式,需要对设备版本进行判断</p>

<pre><code>// 定位管理者
_locManager = [[CLLocationManager alloc] init];
[_locManager setDelegate:self];
[_locManager setDesiredAccuracy:kCLLocationAccuracyBest];
#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_1 
if ([_locManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) {
    [_locManager requestWhenInUseAuthorization];
    [_locManager requestAlwaysAuthorization];
}
#endif
CLAuthorizationStatus status = [CLLocationManager authorizationStatus];
if (kCLAuthorizationStatusDenied == status || kCLAuthorizationStatusRestricted == status) {
    [LSHelper alertWithTitle:@"定位失败" message:@"您的本次拜访将无法记录位置信息，请在设置中打开您的位置服务，并重新进入该页面！"];
}
else {
    [_locManager startUpdatingLocation];
    [self showProgressViewWithTitle:@"定位中..."];
}
</code></pre>

<h4>地理编码</h4>

<p>以下是代理方法:</p>

<pre><code>- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation {
    [_locManager stopUpdatingLocation];
    [self hideProgressView];
    CLLocationCoordinate2D loc = [newLocation coordinate];
    _locLatitude = [[NSString stringWithFormat:@"%f",loc.latitude] floatValue] + 0.00130;
    _locLongitude = [[NSString stringWithFormat:@"%f",loc.longitude] floatValue] + 0.00625;

    CLLocation *location = [[CLLocation alloc] initWithLatitude:_locLatitude longitude:_locLongitude];
    [self.geoCoder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
        if (error || placemarks.count == 0) {
            [self.view makeToast:@"定位失败，请稍后重试！"];
            [self.locBtn setBackgroundImage:[UIImage imageNamed:@"MapPinGray"] forState:UIControlStateNormal];
            [self.locBtn addTarget:self action:@selector(locationIconBtnClick) forControlEvents:UIControlEventTouchUpInside];
            self.locLab.textColor = [UIColor redColor];
            self.locLab.text = @"未定位成功";
        } else {
            [self.view makeToast:@"定位成功！"];
            self.locBtn.enabled = NO;
            [self.locBtn setBackgroundImage:[UIImage imageNamed:@"MapPin@2x"] forState:UIControlStateNormal];
            self.locLab.textColor = [UIColor blackColor];
            CLPlacemark *firstPlacemark = [placemarks firstObject];
            self.locLab.text = firstPlacemark.name;
        }
    }];
}

- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error {
    [_locManager stopUpdatingLocation];
    [self hideProgressView];
    [LSHelper alertWithTitle:@"定位失败，请稍后重试！" message:nil];

    [self.locBtn setBackgroundImage:[UIImage imageNamed:@"MapPinGray"] forState:UIControlStateNormal];
    [self.locBtn addTarget:self action:@selector(locationIconBtnClick) forControlEvents:UIControlEventTouchUpInside];
    self.locLab.textColor = [UIColor redColor];
    self.locLab.text = @"未定位成功";
}
</code></pre>

<p>高德地图的火星坐标需要进行处理,在此代理方法中对坐标进行地理编码操作,注意: 定位可以在没有网络的情况下进行,但是地理编码需要依靠网络.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/30/afnetworkingyuan-ma-jie-xi-san/">AFNetworking源码解析(三)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-30T15:02:47+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文地址：<a href="http://www.cocoachina.com/ios/20140916/9632.html">http://www.cocoachina.com/ios/20140916/9632.html</a></p>

<p>安全相关的AFSecurityPolicy模块，AFSecurityPolicy用于验证HTTPS请求的证书，先来看看HTTPS的原理和证书相关的几个问题。</p>

<p>HTTPS
HTTPS连接建立过程大致是，客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有各个受信任的证书机构根证书，用这些根证书对服务端 返回的证书进行验证，经验证如果证书是可信任的，就生成一个pre-master  secret，用这个证书的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master  secret，客户端也同样根据这种算法从pre-master secret生成master secret，随后双方的通信都用这个master  secret对传输数据进行加密解密。</p>

<p>这里说下一开始我比较费解的两个问题：</p>

<h4>1.证书是怎样验证的？怎样保证中间人不能伪造证书？</h4>

<p>首先要知道非对称加密算法的特点，非对称加密有一对公钥私钥，用公钥加密的数据只能通过对应的私钥解密，用私钥加密的数据只能通过对应的公钥解密。</p>

<p>我们来看最简单的情况：一个证书颁发机构(CA)，颁发了一个证书A，服务器用这个证书建立https连接。客户端在信任列表里有这个CA机构的根证书。</p>

<p>首先CA机构颁发的证书A里包含有证书内容F，以及证书加密内容F1，加密内容F1就是用这个证书机构的私钥对内容F加密的结果。（这中间还有一次hash算法，略过。）</p>

<p>建立https连接时，服务端返回证书A给客户端，客户端的系统里的CA机构根证书有这个CA机构的公钥，用这个公钥对证书A的加密内容F1解密得 到F2，跟证书A里内容F对比，若相等就通过验证。整个流程大致是：F->CA私钥加密->F1->客户端CA公钥解密->F。 因为中间人不会有CA机构的私钥，客户端无法通过CA公钥解密，所以伪造的证书肯定无法通过验证。</p>

<h4>2.什么是SSL Pinning？</h4>

<p>可以理解为证书绑定，是指客户端直接保存服务端的证书，建立https连接时直接对比服务端返回的和客户端保存的两个证书是否一样，一样就表明证书 是真的，不再去系统的信任证书机构里寻找验证。这适用于非浏览器应用，因为浏览器跟很多未知服务端打交道，无法把每个服务端的证书都保存到本地，但CS架 构的像手机APP事先已经知道要进行通信的服务端，可以直接在客户端保存这个服务端的证书用于校验。</p>

<p>为什么直接对比就能保证证书没问题？如果中间人从客户端取出证书，再伪装成服务端跟其他客户端通信，它发送给客户端的这个证书不就能通过验证吗？确 实可以通过验证，但后续的流程走不下去，因为下一步客户端会用证书里的公钥加密，中间人没有这个证书的私钥就解不出内容，也就截获不到数据，这个证书的私 钥只有真正的服务端有，中间人伪造证书主要伪造的是公钥。</p>

<p>为什么要用SSL  Pinning？正常的验证方式不够吗？如果服务端的证书是从受信任的的CA机构颁发的，验证是没问题的，但CA机构颁发证书比较昂贵，小企业或个人用户 可能会选择自己颁发证书，这样就无法通过系统受信任的CA机构列表验证这个证书的真伪了，所以需要SSL Pinning这样的方式去验证。</p>

<p>AFSecurityPolicy
NSURLConnection已经封装了https连接的建立、数据的加密解密功能，我们直接使用NSURLConnection是可以访问 https网站的，但NSURLConnection并没有验证证书是否合法，无法避免中间人攻击。要做到真正安全通讯，需要我们手动去验证服务端返回的 证书，AFSecurityPolicy封装了证书验证的过程，让用户可以轻易使用，除了去系统信任CA机构列表验证，还支持SSL  Pinning方式的验证。使用方法：</p>

<pre><code>//把服务端证书(需要转换成cer格式)放到APP项目资源里，AFSecurityPolicy会自动寻找根目录下所有cer文件
AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];
securityPolicy.allowInvalidCertificates = YES;
[AFHTTPRequestOperationManager manager].securityPolicy = securityPolicy;
[manager GET:@"https://example.com/" parameters:nil success:^(AFHTTPRequestOperation *operation, id     responseObject) {
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
}];
</code></pre>

<p>AFSecurityPolicy分三种验证模式：</p>

<p>AFSSLPinningModeNone</p>

<p>这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</p>

<p>AFSSLPinningModeCertificate</p>

<p>这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</p>

<p>这里还没弄明白第一步的验证是怎么进行的，代码上跟去系统信任机构列表里验证一样调用了SecTrustEvaluate，只是这里的列表换成了客户端保存的那些证书列表。若要验证这个，是否应该把服务端证书的颁发机构根证书也放到客户端里？</p>

<p>AFSSLPinningModePublicKey</p>

<p>这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</p>

<p>整个AFSecurityPolicy就是实现这这几种验证方式，剩下的就是实现细节了，详见源码。</p>

<h4>3.源码注释</h4>

<p>AFSecurityPolicy</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/23/shen-kao-bei-yu-qian-kao-bei-fen-xi/">深拷贝与浅拷贝分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/13/li-yong-crashdui-zhan-xin-xi-ding-wei-dian-xing-de-ye-zhi-zhen-cuo-wu/">利用crash堆栈信息定位典型的野指针错误</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/12/li-yong-crashdui-zhan-xin-xi-ding-wei-dai-ma-beng-kui-wei-zhi/">利用crash堆栈信息定位代码崩溃位置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/05/uiwebviewxiu-gai-ye-mian-xiang-guan/">UIWebView修改页面相关</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/05/ioskai-fa-zhong-%5B%3F%5D-xie-xiao-ji-qiao/">iOS开发中一些小技巧</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - zhao yan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
